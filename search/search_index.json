{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Git Tutorial","text":""},{"location":"#welcome-to-git-notes-reference","title":"Welcome to Git Notes &amp; Reference!","text":"<p>Helloo, </p> <p>This website is designed to help me take notes, reference, and learn Git and GitHub efficiently. It\u2019s also open for anyone else who wants to learn Git or use it to take as a reference.</p> <p>Navigate through the sidebar to explore structured guides, examples, and best practices.</p>"},{"location":"#why-this-site-exists","title":"Why this site exists","text":"<ul> <li>Git is a powerful version control system, but it can be confusing at first.</li> <li>Writing notes helps me solidify my understanding and remember important commands.</li> <li>By turning my notes into a website, I can access them from anywhere and share them with friends, classmates, or anyone curious about Git.</li> <li>The structure allows for easy navigation, so you can quickly find the topic you need.</li> </ul>"},{"location":"#what-you-will-find-here","title":"What you will find here","text":"<ul> <li>Git Basics: Commands like <code>git init</code>, <code>git add</code>, <code>git commit</code>, and <code>git push</code>.</li> <li>Branching &amp; Merging: Learn how to create branches, merge changes, and handle conflicts.</li> <li>Advanced Git: Interactive staging, amending commits, signing commits, and other professional workflows.</li> <li>Examples &amp; Exercises: Real-world scenarios to practice commands and reinforce learning.</li> <li>References: Links to official Git documentation, tutorials, and books for deeper learning.</li> </ul>"},{"location":"#how-to-use-this-site","title":"How to use this site","text":"<ol> <li>Start with the Git Basics section if you are new.</li> <li>Move on to Branching &amp; Merging to understand workflows and team collaboration.</li> <li>Explore Advanced Git for tips and commands used in professional development.</li> <li>Use the References page for external resources and further reading.</li> <li>You can also search for keywords in the top-right search box to find commands quickly.</li> </ol>"},{"location":"DiveDeeperIntoBasics/","title":"Git Dive Deep","text":""},{"location":"DiveDeeperIntoBasics/#git-init","title":"git init","text":"<ul> <li>default branch created while using git init is the master branch.</li> <li>When we initialize the repo, two regions are created.</li> <li>Staging area (where changes are prepared before commit)</li> <li>Non-staging area (working directory with untracked/modified files)</li> </ul> <p>The <code>.git</code> directory contains:</p> <ul> <li>HEAD file (references current branch)</li> <li>config file (repository configuration)</li> <li>objects directory (stores all content)</li> <li>refs directory (stores pointers to commits)</li> </ul>"},{"location":"DiveDeeperIntoBasics/#remove-a-local-git-repo","title":"Remove a local git repo","text":"<pre><code>rm -rf .git/\n</code></pre> <p>This deletes the repository history.</p>"},{"location":"DiveDeeperIntoBasics/#rename-default-branch-name","title":"Rename default branch name","text":"<pre><code>git init --initial-branch=main\n</code></pre> <p>Sets initial branch to main instead of master.</p> <p>Nested git repository. Never create a git repo inside a repo. Avoid this to avoid chaos.</p> <p>Never create a git repo inside another repo (except for submodules)</p> <p>Potential issues:</p> <ul> <li> <p>Conflicting .git directories</p> </li> <li> <p>Confusing version control boundaries</p> </li> <li> <p>Complex merge behaviors</p> </li> </ul>"},{"location":"DiveDeeperIntoBasics/#git-add","title":"git add","text":""},{"location":"DiveDeeperIntoBasics/#core-functionality","title":"Core Functionality","text":"<p>Stages changes from working directory to staging area</p>"},{"location":"DiveDeeperIntoBasics/#advanced-usage","title":"Advanced Usage","text":"<p>Add a part of file to the staged area.</p>"},{"location":"DiveDeeperIntoBasics/#interactive-add-choose-hunks","title":"Interactive add (choose hunks)","text":"<pre><code>git add -p\n</code></pre>"},{"location":"DiveDeeperIntoBasics/#add-all-tracked-files-not-new-files","title":"Add all tracked files (not new files)","text":"<pre><code>git add -u\n</code></pre>"},{"location":"DiveDeeperIntoBasics/#add-all-tracked-and-untracked-files","title":"Add all tracked and untracked files","text":"<pre><code>git add -A\n</code></pre> <pre><code># Add by file pattern\ngit add '*.js'\n</code></pre>"},{"location":"DiveDeeperIntoBasics/#behind-the-scenes","title":"Behind the Scenes","text":"<ul> <li>Creates SHA-1 hashes of file contents</li> <li>Stores compressed versions in object database</li> <li>Updates index file with new file modes and hashes</li> </ul>"},{"location":"DiveDeeperIntoBasics/#git-commit","title":"git commit","text":""},{"location":"DiveDeeperIntoBasics/#commit-anatomy","title":"Commit Anatomy","text":"<p>Creates a commit object containing:</p> <ul> <li>Author info</li> <li>Commit message</li> <li>Pointer to tree object (snapshot of repo)</li> <li>Pointer to parent commit(s)</li> </ul>"},{"location":"DiveDeeperIntoBasics/#advanced-options","title":"Advanced Options","text":"<pre><code># Amend previous commit\ngit commit --amend\n\n# Amend previous commit with no commit message\ngit commit --amend --no-edit\n\n# Sign commit cryptographically\ngit commit -S\n\n# Commit with multiline message\ngit commit -m \"Title\" -m \"Description\"\n\n# Commit with no changes (run pipeline)\ngit commit --allow-empty -m \"dummy\"\n</code></pre>"},{"location":"DiveDeeperIntoBasics/#technical-details","title":"Technical Details","text":"<ul> <li>Each commit has a unique SHA-1 hash</li> <li>Commit objects reference tree objects</li> <li>Tree objects reference blob objects (files) and other trees</li> </ul>"},{"location":"DiveDeeperIntoBasics/#git-push","title":"git push","text":""},{"location":"DiveDeeperIntoBasics/#advanced-techniques","title":"Advanced Techniques","text":"<pre><code># Push specific branch\ngit push origin branch-name\n\n# Set upstream branch\ngit push -u origin branch-name\n\n# Force push (use with caution)\ngit push --force\n</code></pre>"},{"location":"DiveDeeperIntoBasics/#protocols-and-internals","title":"Protocols and Internals","text":"<ul> <li>Can use HTTPS, SSH, or Git protocol</li> <li>Underlying transfer uses packfiles for efficiency</li> <li>Uses the \"smart\" protocol for modern servers</li> </ul>"},{"location":"DiveDeeperIntoBasics/#push-rejection-scenarios","title":"Push Rejection Scenarios","text":"<ol> <li>Non-fast-forward: Remote has commits you don't have locally</li> <li>Solution: <code>git pull</code> first to merge changes</li> <li>Permission denied: Authentication issues</li> <li>Solution: Check SSH keys or credentials</li> <li>Shallow update not allowed: Pushing from shallow clone</li> <li>Solution: Perform full clone</li> </ol>"},{"location":"DiveDeeperIntoBasics/#git-log","title":"git log","text":"<p>Gives last 2 commits</p> <pre><code>git log -n 2\n</code></pre> <p>Gives diff layout of commit status:</p> <pre><code>git log --pretty= short\n</code></pre> <pre><code>git log --pretty= full\n</code></pre> <pre><code>git log --pretty= fuller\n</code></pre> <pre><code>git log --pretty= oneline\n</code></pre> <pre><code> git log --pretty=form\nat:\"%h\"\n</code></pre> <pre><code># prints commit id\n git log --pretty=format: \"%h\"\n</code></pre> <pre><code># prints commit id and commit message\n git log --pretty=format: \"%h %s \"\n</code></pre> <pre><code>#prints the commit from a week ago\ngit log --since=\"1 week ago\"\n</code></pre> <pre><code>#prints the commit within an interval\ngit log --since=\"02/19/2024\" --until=\"05/20/2025\"\n</code></pre> <pre><code># shows you the commit history with the patch diff included\ngit log -p\n</code></pre> <pre><code>git log\n</code></pre>"},{"location":"DiveDeeperIntoBasics/#summary","title":"Summary","text":"<ul> <li>Head is the pointer to the latest commit.</li> <li>You can change head.</li> <li>Every next commit points to the previous commit. It creates a linked list of commits.</li> </ul>"},{"location":"Introduction/","title":"Git Introduction","text":""},{"location":"Introduction/#what-is-git","title":"What is Git?","text":"<p>Git is a distributed version control system. It helps to track changes in files, typically source code. It allows to collaborate with group of people without overwriting eachother's work.</p>"},{"location":"Introduction/#git-installation","title":"Git Installation","text":""},{"location":"Introduction/#on-macos","title":"On macOS","text":"<p>Git comes bundled with the Command Line Tools for Xcode. To check if it\u2019s installed, open Terminal and type:</p> <pre><code>git --version\n</code></pre> <p>or</p> <pre><code>git -v\n</code></pre>"},{"location":"Introduction/#setting-personal-info-to-git","title":"Setting Personal Info to Git","text":"<p>Git requires you to set your name and email before you start committing changes. This information is stored in your commits.</p> <pre><code>git config --global user.name \"yourusername\"\n</code></pre> <pre><code>git config --global user.email \"youremail@example.com\"\n</code></pre>"},{"location":"Introduction/#basic-commands","title":"Basic Commands","text":"<p>follow along step by step:</p> <ol> <li>Create a folder/ directory called <code>git_module</code></li> </ol> <pre><code>mkdir git_module\ncd git_module\n</code></pre> <ol> <li>Create a subfolder called <code>first_app</code></li> </ol> <pre><code>mkdir first_app\ncd first_app\n</code></pre> <ol> <li>list files in the directory</li> </ol> <pre><code>  ls -l\n</code></pre> <ol> <li>Create a new file in the directory.</li> </ol> <pre><code> nano file1.txt\n</code></pre> <ol> <li> <p>In the text editor, write some texts 7. <code>Ctrl+X</code> and press Y</p> </li> <li> <p>Initialize your git repository</p> </li> </ol> <pre><code>git init\n</code></pre> <p>By this step, you have succesfully initialized a git repo</p>"},{"location":"Introduction/#spoonfeed-git-changes","title":"Spoonfeed git changes","text":"<p>Git doesn\u2019t automatically track changes in your files. You need to tell Git when a file is added, modified, or deleted.</p> <p>Files that Git doesn\u2019t know about are called untracked files.</p> <p>Untracked files aren\u2019t included in commits, and Git won\u2019t keep a history of them until you explicitly add them.</p> <p>If an untracked file is deleted before being added, Git cannot recover it.</p> <p>Tip: Always use git status to see which files are untracked, modified, or staged for commit.</p>"},{"location":"Introduction/#untracked-files-are-in-red","title":"Untracked files are in red:","text":""},{"location":"Introduction/#adding-git-files","title":"Adding git files","text":"<p>This is adding untracked files.</p> <pre><code>git add filename.txt\n</code></pre> <p>Here, the files are transformed from unstaging areas to staging area.</p> <p>If you have mutilple untracked files, then you can track it all at once.</p> <pre><code>git add .\n</code></pre>"},{"location":"Introduction/#git-status","title":"Git Status","text":"<p>To check the status of git:</p> <pre><code>git status\n</code></pre> <p></p> <p>Files that Git already knows about. If changes are staged for commit, they appear in green.. New files Git doesn\u2019t know about yet. These appear in red.</p>"},{"location":"Introduction/#commit-changes","title":"commit changes","text":"<p>Commits the staged changes to the repository. It basically snapshots your repo at a specific point. In other words, it is recording the changes in the repo.</p> <pre><code>git commit\n</code></pre> <p>This opens a text editor to type your commit.</p> <ol> <li>Press I to enable Insert.</li> <li>Type your commit message.</li> <li>Press Escape key.</li> <li>type <code>:wq</code> and press Enter.</li> </ol> <p>If you are smart then just do: (Quick Commit)</p> <pre><code>git commit -m \"your commit message\"\n</code></pre>"},{"location":"Introduction/#commit-history","title":"commit history","text":"<p>View your commit history.</p> <pre><code>git log\n</code></pre> <p>This will display commit hash, Author, Date and Commit message.</p>"},{"location":"Introduction/#summary","title":"Summary","text":"<ol> <li> <p>Create a local repo: <code>git init</code></p> </li> <li> <p>When we create a new file in the repo, git is unaware of it.</p> </li> <li><code>git add filename.extension</code></li> <li>Now git is in staging area and git is aware of the file.</li> <li><code>git commit -m \"commit message\"</code></li> <li><code>git status</code></li> <li><code>git log</code></li> </ol>"},{"location":"branchDiagram/","title":"The Core Purpose of Branching","text":"<ul> <li>Parallel Development: This is the fundamental concept. Branches allow multiple features (e.g., a new UI, a backend optimization, a bug fix) to be developed concurrently by different individuals or teams. Without branching, developers would be constantly stepping on each other's code.</li> <li>Context Switching and Experimentation: A branch is a safe sandbox. You can try a radical new algorithm or refactor a module. If it doesn't work, you simply discard the branch (git branch -D experiment_branch) and no harm is done to the main codebase. This encourages innovation and reduces risk.</li> <li>Synching Vs Asynching:</li> <li> <ul> <li>Head: A pointer to a specific commit (a snapshot of your code).</li> </ul> </li> <li> <ul> <li>Syncing: This means the branches point to the exact same commit, meaning their history is identical at that point.</li> </ul> </li> <li> <ul> <li>Behind/Ahead: This describes the state of a branch's history relative to another branch.     icecream is one commit behind master means the commit that icecream points to is a direct parent of the commit that master points to. To \"sync\" them, you would need to bring the changes from master into icecream (usually with a merge or rebase).</li> </ul> </li> </ul>"},{"location":"branching/","title":"Intro to Branching","text":""},{"location":"branching/#what-are-the-purpose-of-branches","title":"what are the purpose of branches?","text":"<ul> <li>Branches let you work on new features, fixes, or experiments independently without affecting the main code. They also make collaboration and version management easier by keeping changes organized and separate until ready to merge</li> </ul> <ul> <li>branch icecream and cake are not syncing because they have diff heads.</li> <li>branch cake and master are syncing because they have the same head.</li> <li>icecream branch is one commit behind master.</li> </ul>"},{"location":"branching/#commands","title":"commands","text":"<ul> <li>Check local branches</li> </ul> <pre><code># info about LOCAL branches\ngit branch\n</code></pre> <ul> <li>Create a branch</li> </ul> <pre><code># create a local branch\ngit branch branchname\n</code></pre> <p>Notes: both the main and jamisha branch are in the same head. Hence, they are syncing</p> <p></p> <ul> <li>change branch</li> </ul> <pre><code># create a local branch\ngit checkout branchname\n</code></pre> <p>now since we are in another branch named jamisha. If we commit changes then it wont commit to any other branches.</p> <p>main is one commit away from jamisha branch. They are not syncing </p> <ul> <li>delete branches</li> </ul> <pre><code>git branch -d branchname\n</code></pre>"},{"location":"gitCommands/","title":"Quick Reference","text":""},{"location":"gitCommands/#1-setup-configuration","title":"1. Setup &amp; Configuration","text":"<pre><code>git config --global user.name \"Your Name\"      # Set username\ngit config --global user.email \"you@example.com\"  # Set email\ngit config --global color.ui auto              # Enable colored output\ngit config --list                               # Show current config\n</code></pre>"},{"location":"gitCommands/#2-creating-repositories","title":"2. Creating Repositories","text":"<pre><code>git init                                      # Initialize local repo\ngit clone &lt;url&gt;                               # Clone remote repo\n</code></pre>"},{"location":"gitCommands/#3-checking-status-history","title":"3. Checking Status &amp; History","text":"<pre><code>git status                                    # Show staged, unstaged, and untracked files\ngit log                                       # Show commit history\ngit log --oneline                             # Short commit history\ngit log --graph --all --decorate              # Visual commit graph\ngit diff                                      # Show unstaged changes\ngit diff --staged                             # Show staged changes\n</code></pre>"},{"location":"gitCommands/#4-staging-committing","title":"4. Staging &amp; Committing","text":"<pre><code>git add &lt;file&gt;                                # Stage a file\ngit add .                                     # Stage all changes in current directory\ngit add -A                                    # Stage all changes including deletions\ngit commit -m \"Commit message\"               # Commit staged changes\ngit commit -am \"Message\"                      # Stage tracked files and commit\ngit reset &lt;file&gt;                              # Unstage a file\n</code></pre>"},{"location":"gitCommands/#5-branching","title":"5. Branching","text":"<pre><code>git branch                                    # List local branches\ngit branch -r                                 # List remote branches\ngit branch -a                                 # List all branches\ngit branch &lt;name&gt;                             # Create new branch\ngit checkout &lt;branch&gt;                         # Switch branch\ngit checkout -b &lt;branch&gt;                      # Create + switch\ngit switch &lt;branch&gt;                           # Switch branch (newer syntax)\ngit switch -c &lt;branch&gt;                        # Create + switch (newer syntax)\n</code></pre>"},{"location":"gitCommands/#6-merging","title":"6. Merging","text":"<pre><code>git merge &lt;branch&gt;                            # Merge branch into current\ngit merge --no-ff &lt;branch&gt;                    # Create merge commit even if fast-forward possible\ngit mergetool                                 # Launch tool to resolve conflicts\n</code></pre>"},{"location":"gitCommands/#7-cherry-picking","title":"7. Cherry-Picking","text":"<pre><code>git cherry-pick &lt;commit-hash&gt;                 # Apply a specific commit to current branch\n</code></pre>"},{"location":"gitCommands/#8-rebasing","title":"8. Rebasing","text":"<pre><code>git rebase &lt;branch&gt;                           # Reapply commits on top of another branch\ngit rebase --interactive &lt;branch&gt;            # Edit, squash, or reorder commits\ngit rebase --abort                            # Abort rebase if conflicts\ngit rebase --continue                         # Continue after resolving conflicts\n</code></pre>"},{"location":"gitCommands/#9-resetting-reverting","title":"9. Resetting &amp; Reverting","text":"<pre><code>git reset --soft &lt;commit&gt;                     # Move HEAD, keep changes staged\ngit reset --mixed &lt;commit&gt;                    # Move HEAD, keep changes unstaged\ngit reset --hard &lt;commit&gt;                     # Move HEAD, discard changes\ngit revert &lt;commit&gt;                           # Create a commit that undoes a previous commit\n</code></pre>"},{"location":"gitCommands/#10-remote-repositories","title":"10. Remote Repositories","text":"<pre><code>git remote -v                                 # Show remotes\ngit remote add &lt;name&gt; &lt;url&gt;                   # Add a remote\ngit remote remove &lt;name&gt;                      # Remove a remote\ngit remote rename &lt;old&gt; &lt;new&gt;                 # Rename a remote\ngit remote set-url &lt;name&gt; &lt;url&gt;              # Change remote URL\n\ngit fetch &lt;remote&gt;                            # Fetch changes from remote\ngit fetch --all                               # Fetch from all remotes\ngit pull &lt;remote&gt; &lt;branch&gt;                    # Fetch + merge\ngit push &lt;remote&gt; &lt;branch&gt;                    # Push local branch to remote\ngit push -u &lt;remote&gt; &lt;branch&gt;                # Push + set upstream\ngit push --all &lt;remote&gt;                       # Push all branches\ngit push --tags &lt;remote&gt;                      # Push tags\ngit push &lt;remote&gt; --delete &lt;branch&gt;          # Delete remote branch\ngit branch --set-upstream-to=&lt;remote&gt;/&lt;branch&gt;  # Link local branch to remote\n</code></pre>"},{"location":"gitCommands/#11-stashing","title":"11. Stashing","text":"<pre><code>git stash                                     # Save uncommitted changes\ngit stash list                                # Show stashes\ngit stash apply                               # Apply latest stash\ngit stash pop                                 # Apply and remove latest stash\ngit stash drop                                # Delete a stash\ngit stash clear                               # Remove all stashes\n</code></pre>"},{"location":"gitCommands/#12-undoing-changes","title":"12. Undoing Changes","text":"<pre><code>git checkout -- &lt;file&gt;                        # Discard local changes in a file\ngit clean -f                                  # Remove untracked files\ngit reflog                                    # Show history of HEAD moves\n</code></pre>"},{"location":"gitCommands/#13-viewing-differences","title":"13. Viewing Differences","text":"<pre><code>git diff                                      # Unstaged changes\ngit diff --staged                             # Staged changes\ngit diff &lt;branch&gt;                             # Differences from another branch\ngit show &lt;commit&gt;                             # Show commit details\n</code></pre>"},{"location":"gitCommands/#14-helpful-tips","title":"14. Helpful Tips","text":"<ul> <li><code>git log --oneline --graph --decorate --all</code> \u2192 visualize history.</li> <li><code>git blame &lt;file&gt;</code> \u2192 see who last changed each line.</li> <li><code>git shortlog</code> \u2192 summarize commits by author.</li> </ul>"},{"location":"gitEssentials/","title":"git reset","text":"<p>Using <code>git reset</code> you can:</p> <ul> <li>unstage files</li> <li>undo commits</li> <li>delete commits</li> </ul> <p>The modes of <code>git reset</code> are:</p> <ul> <li>soft, mixed, hard</li> </ul> <pre><code># bring the file to staging area\ngit reset --soft commitHash\n</code></pre> <pre><code># bring the file to unstaging area\ngit reset --mixed commitHash\n</code></pre> <pre><code># deletes the file. DANGEROUSS\ngit reset --hard commitHash\n</code></pre>"},{"location":"gitEssentials/#git-revert","title":"git revert","text":"<pre><code>git revert commitHash\n</code></pre>"},{"location":"gitEssentials/#soo-what-is-the-difference-between-git-revert-and-git-reset-hard","title":"Soo, what is the difference between <code>git revert</code> and <code>git reset --hard</code>","text":"<ul> <li><code>git revert</code>- undos safely, creates a new commit   you can recheck the old content using   <code>git checkout hash</code></li> </ul> <ul> <li><code>git reset --hard</code> - deletes history, dangerous   you cannot recheck teh old content ones deleted <code>:(</code></li> </ul>"},{"location":"gitIgnore/","title":".gitignore","text":"<p>Purpose: A <code>.gitignore</code> file tells Git which files or folders to ignore and not track. It keeps your repository clean and safe.</p> <p>Why Use It?</p> <ul> <li>Avoid tracking unnecessary files (logs, build folders, OS files)</li> <li>Prevent accidentally committing secrets (API keys, passwords)</li> <li>Reduce repository size and clutter</li> </ul> <p>How It Works:</p> <ol> <li>Create a file named <code>.gitignore</code> in your project's root directory.</li> <li>Add patterns for files/directories to ignore.</li> <li>Git automatically excludes them from tracking.</li> </ol> <p>Common Patterns:</p> <ul> <li><code>*.log</code> - Ignore all files with <code>.log</code> extension</li> <li><code>node_modules/</code> - Ignore entire directory</li> <li><code>.env</code> - Ignore environment files (often contain secrets)</li> <li><code>!important.log</code> - Exception: do NOT ignore this file</li> </ul> <p>Key Rule: If a file is already tracked by Git, adding it to <code>.gitignore</code> won't stop tracking. Use <code>git rm --cached &lt;file&gt;</code> to remove it first.</p> <p>Pro Tip: Use templates from gitignore.io for your programming language or IDE.</p>"},{"location":"gitLab/","title":"GitHub vs. GitLab:","text":"<p>Web platforms that host remote Git repositories + add powerful collaboration tools.</p>"},{"location":"gitLab/#github","title":"GitHub","text":"<ul> <li>Focus: Social coding and open source. The world's largest code host.</li> <li>Key Feature: Pull Requests are the core of its collaboration model.</li> <li>Community: Massive public community. The default portfolio for developers.</li> <li>vibe: \"The social network for code.\"</li> </ul>"},{"location":"gitLab/#gitlab","title":"GitLab","text":"<ul> <li>Focus: DevOps lifecycle and enterprise features. \"Single application for entire DevOps lifecycle.\"</li> <li>Key Feature: Built-in CI/CD (automated testing/deployment) is free and integrated.</li> <li>Deployment: Offers both cloud (SaaS) and self-hosted options (install on your own server).</li> <li>vibe: \"The all-in-one DevOps platform.\"</li> </ul>"},{"location":"gitLab/#the-core-similarity","title":"The Core Similarity","text":"<p>Both provide the essential Git hosting services:</p> <ul> <li><code>git push</code>, <code>git pull</code>, <code>git clone</code></li> <li>Code browsing</li> <li>Issue tracking</li> <li>Code review</li> </ul> <p>In short:</p> <ul> <li>Use GitHub for its massive community and as your coding portfolio.</li> <li>Use GitLab for its powerful, integrated DevOps and CI/CD tools, especially if you need self-hosting.</li> </ul>"},{"location":"gitStash/","title":"Git Stash: Essential Commands","text":"<p>git stash is a command that temporarily shelves (saves) the changes you're currently working on. It lets you quickly clean up your workspace without having to make a permanent commit, so you can switch to another task. When you're ready, you can \"unpause\" and get your changes back exactly as you left them.</p>"},{"location":"gitStash/#save-work","title":"Save Work","text":"<pre><code>git stash                      # Shelve all current changes\ngit stash -m \"message\"         # Shelve with a description\n</code></pre>"},{"location":"gitStash/#view-restore","title":"View &amp; Restore","text":"<pre><code>git stash list                 # Show all shelved items\ngit stash pop                  # Restore latest &amp; remove from shelf\ngit stash apply                # Restore latest but keep on shelf\n</code></pre>"},{"location":"gitStash/#clean-up","title":"Clean Up","text":"<pre><code>git stash drop                 # Discard latest shelved item\ngit stash clear                # Empty entire shelf\n</code></pre>"},{"location":"gitStash/#advanced","title":"Advanced","text":"<pre><code>git stash --keep-index         # Shelve but keep staged files\ngit stash --include-untracked  # Shelve including new files\n</code></pre>"},{"location":"git_cherrypick/","title":"Git Cherry-Pick (in depth)","text":""},{"location":"git_cherrypick/#core-concept","title":"Core Concept","text":"<p><code>git cherry-pick</code> applies the changes from an existing commit to your current branch as a new commit.</p>"},{"location":"git_cherrypick/#basic-syntax","title":"Basic Syntax","text":"<pre><code>git cherry-pick &lt;commit-hash&gt;\n</code></pre>"},{"location":"git_cherrypick/#common-use-cases","title":"Common Use Cases","text":"<p>Apply a single commit</p> <pre><code>git cherry-pick abc1234\n</code></pre> <p>Apply multiple commits</p> <pre><code>git cherry-pick abc1234 def5678\n</code></pre> <p>Apply a range of commits</p> <pre><code>git cherry-pick abc1234..def5678\n</code></pre>"},{"location":"git_cherrypick/#advanced-options","title":"Advanced Options","text":"<p>Edit commit message before applying</p> <pre><code>git cherry-pick -e &lt;commit-hash&gt;\n</code></pre> <p>Apply changes without committing</p> <pre><code>git cherry-pick -n &lt;commit-hash&gt;\n</code></pre> <p>Sign off on the cherry-picked commit</p> <pre><code>git cherry-pick -s &lt;commit-hash&gt;\n</code></pre>"},{"location":"git_cherrypick/#handling-conflicts","title":"Handling Conflicts","text":"<p>When conflicts occur:</p> <pre><code># Resolve conflicts manually, then:\ngit add &lt;resolved-files&gt;\ngit cherry-pick --continue\n\n# Or abort the operation:\ngit cherry-pick --abort\n</code></pre>"},{"location":"git_cherrypick/#practical-examples","title":"Practical Examples","text":"<p>Copy a bug fix from another branch</p> <pre><code>git checkout main\ngit cherry-pick feature-branch~2  # Apply second-to-last commit from feature branch\n</code></pre> <p>Selective backporting</p> <pre><code>git checkout production\ngit cherry-pick abc1234 def5678  # Apply specific fixes to production\n</code></pre>"},{"location":"git_cherrypick/#important-considerations","title":"Important Considerations","text":"<p>Commit History Implications</p> <ul> <li>Cherry-picking creates new commit hashes</li> <li>Original commit metadata (author, date) is preserved</li> <li>The new commit is unrelated to the original in the commit tree</li> </ul> <p>When to Avoid Cherry-Picking</p> <ul> <li>Large feature sets (better to merge)</li> <li>Commits with complex dependencies</li> <li>When you want to preserve commit relationships</li> </ul>"},{"location":"git_cherrypick/#best-practices","title":"Best Practices","text":"<ol> <li>Test after cherry-picking - Ensure the changes work in the new context</li> <li>Document why - Add context in commit messages about why cherry-pick was used</li> <li>Consider alternatives - Rebase or merge might be more appropriate</li> </ol>"},{"location":"git_cherrypick/#difference-between-cherrypick-and-merge","title":"Difference between cherrypick and Merge","text":"<ul> <li>cherry-pick is copying a specific commit</li> <li>merge is integrating an entire branch history</li> </ul>"},{"location":"git_cherrypick/#performance-notes","title":"Performance Notes","text":"<ul> <li>Cherry-picking is generally fast for small changes</li> <li>Complex conflicts can significantly slow down the process</li> <li>Large commits or binary files may take longer to process</li> </ul> <p>Remember: Cherry-picking is a powerful tool, but it should be used judiciously as it can create duplicate commits and complicate history understanding.</p>"},{"location":"mergeConflicts/","title":"Resolving Conflicts","text":""},{"location":"mergeConflicts/#git-merge-conflicts","title":"Git Merge Conflicts","text":""},{"location":"mergeConflicts/#1-what-is-a-merge-conflict","title":"1. What is a Merge Conflict?","text":"<p>A merge conflict is an event that occurs when Git cannot automatically reconcile the changes from two different branches. It is not an error or a failure of Git; it is a logical inevitability when concurrent, incompatible changes are made to the same parts of a file.</p> <p>Git's automatic merging is excellent for combining changes that don't touch the same lines (e.g., you change function <code>A</code> and I change function <code>B</code>). A conflict arises when this is not the case.</p>"},{"location":"mergeConflicts/#2-when-do-conflicts-happen","title":"2. When Do Conflicts Happen?","text":"<p>Conflicts occur during operations that combine history:</p> <ul> <li><code>git merge</code></li> <li><code>git rebase</code></li> <li><code>git cherry-pick</code></li> <li><code>git pull</code> (which is essentially <code>fetch</code> + <code>merge</code>)</li> </ul>"},{"location":"mergeConflicts/#3-the-root-cause-divergent-changes","title":"3. The Root Cause: Divergent Changes","text":"<p>A conflict requires two conditions to be true simultaneously:</p> <ol> <li>The same file was changed in both branches.</li> <li>The same part(s) of that file were changed in different ways.</li> </ol> <p>Example Scenario:</p> <ol> <li>Branch <code>main</code> has a line: <code>favorite_ice_cream = \"vanilla\"</code></li> <li>You branch off to <code>feature/cake</code> and change it to: <code>favorite_dessert = \"chocolate cake\"</code></li> <li>Someone else on <code>main</code> changes it to: <code>favorite_ice_cream = \"pistachio\"</code></li> <li>Attempting to merge <code>feature/cake</code> into <code>main</code> will cause a conflict. Git doesn't know which variable name (<code>favorite_ice_cream</code> vs. <code>favorite_dessert</code>) or which value (<code>\"pistachio\"</code> vs. <code>\"chocolate cake\"</code>) to choose. This requires human judgment.</li> </ol>"},{"location":"mergeConflicts/#4-anatomy-of-a-conflict-marker","title":"4. Anatomy of a Conflict Marker","text":"<p>When a conflict occurs, Git modifies the file in your working directory to show you the conflicting sections. It uses a specific syntax:</p> <pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nThis is the change that is currently on your branch (the one you are on).\n=======\nThis is the change that is coming from the branch you are merging in.\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-being-merged\n</code></pre> <ul> <li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>: Marks the start of the conflicting changes from your current branch.</li> <li><code>=======</code>: The divider between the two conflicting sets of changes.</li> <li><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-name</code>: Marks the end of the conflicting changes from the incoming branch.</li> </ul>"},{"location":"mergeConflicts/#what-happens","title":"What Happens?","text":"<p>Git can't automatically combine changes from two branches because they edited the same part of the same file. It asks you to decide what the final code should be.</p>"},{"location":"mergeConflicts/#what-youll-see-in-the-file","title":"What You'll See in the File","text":"<p>Git adds markers to show the conflict:</p> <pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nYour changes (from your current branch)\n=======\nIncoming changes (from the branch you're merging)\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-name\n</code></pre> <ul> <li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> to <code>=======</code> is your code.</li> <li><code>=======</code> to <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-name</code> is their code.</li> </ul>"},{"location":"mergeConflicts/#how-to-fix-it-4-steps","title":"How to Fix It: 4 Steps","text":"<ol> <li> <p>Find the conflicts:</p> <pre><code>git status\n</code></pre> <p>Look for \"Unmerged paths\".</p> </li> <li> <p>Open the file and find the <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> markers.</p> </li> <li> <p>Edit the file to choose the correct code. You can:</p> <ul> <li>Keep only your code</li> <li>Keep only their code</li> <li>Mix them together</li> <li>Write something new</li> <li>Delete all the conflict markers (<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>)</li> </ul> </li> <li> <p>Finish up: <pre><code>git add &lt;file&gt;  # Mark this file as fixed\ngit commit      # Finalize the merge\n</code></pre></p> </li> <li>Commit the changes</li> </ol>"},{"location":"merging/","title":"Git Merge","text":"<p><code>git merge</code> is used to combine changes from one branch into another.</p>"},{"location":"merging/#git-merge_1","title":"git merge","text":"<pre><code>git merge &lt;branch-name&gt;\n</code></pre>"},{"location":"merging/#example","title":"Example","text":"<p>Suppose you are on <code>main</code> and want to merge a feature branch called <code>feature1</code>:</p> <pre><code>git checkout main      # Make sure you are on the branch you want to merge into\ngit merge feature1     # Merge changes from feature1 into main\n</code></pre> <ul> <li>If there are no conflicts, Git will automatically merge the changes.</li> <li>If conflicts exist, Git will prompt you to resolve them manually.</li> </ul> <ul> <li> <p>Git combines changes from both branches since they split from a common ancestor.</p> </li> <li> <p>Any new files in the branch being merged that aren\u2019t in your current branch will be added.</p> </li> <li> <p>Any changes to existing files in the merged branch will be applied to your current branch.</p> </li> <li> <p>If both branches changed the same part of a file, Git will ask you to resolve a merge conflict.</p> </li> </ul>"},{"location":"merging/#important-git-scenario","title":"Important git scenario","text":"<p>Explanation: The master branch is split into two branches at commit 3: feature1 and feature2.</p> <ul> <li> <p>feature1 adds a new commit, F1.</p> </li> <li> <p>feature2 adds a new commit, F2.</p> </li> </ul> <p>At this point, the branches have diverged and are not in sync.</p> <p>When we merge master with feature1, both master and feature1 point to F1, so they are now in sync.</p> <p>If we then try to merge master with feature2, Git detects a conflict because feature1\u2019s changes are not in feature2.</p> <p>To resolve this, Git creates a new merge commit that combines the changes from both feature1 and feature2, ensuring that all files from both branches are preserved.</p>"},{"location":"merging/#summary","title":"Summary","text":"<p>Git branches share a common ancestor (the commit where they split).</p> <p>When you merge, Git replays the changes made on one branch into the other.</p> <p>The branch you merge into will now have:</p> <p>Its own commits/files, plus</p> <p>The new commits/files from the other branch.</p> <p>The branch you merged from does not change. So, after git merge branch2 while on branch1:</p> <ul> <li> <p>branch1 = has everything from branch1 + branch2.</p> </li> <li> <p>branch2 = stays the same.</p> </li> </ul>"},{"location":"remotes/","title":"Remote Repository","text":""},{"location":"remotes/#intro","title":"Intro","text":"<p>A remote is simply a Git repository that lives on another machine, serving as a designated common ancestor for a distributed team. It is the bridge that connects your local, isolated development history to the shared project timeline.  It is a new synchronized paradigmn.</p> <p>It allows you to share and collaborate with other developers by providing a central, common reference point (the remote repository) to synchronize your work.</p> <pre><code>git remote add origin url\n</code></pre> <pre><code>#Use to check which remotes are already connected\ngit remote -v\n</code></pre> <pre><code>git remote rename &lt;old&gt; &lt;new&gt;\n</code></pre> <pre><code>#remove a remote\ngit remote remove &lt;name&gt;\n</code></pre> <pre><code>git branch -r\n</code></pre> <pre><code># Syntax: git push &lt;remote-name&gt; &lt;branch-name&gt;\ngit push origin main\n</code></pre> <pre><code>git push -u origin main\n# After this, you can just use:\ngit push\ngit pull\n</code></pre>"},{"location":"remotes/#cloning","title":"Cloning","text":"<p>git clone is the command to create a complete, new local copy of an entire remote repository.</p> <pre><code># Syntax: git clone &lt;repository-url&gt;\ngit clone https://github.com/user/project-name.git\n</code></pre>"},{"location":"remotes/#fetching","title":"Fetching","text":"<pre><code>git fetch &lt;remote&gt; # Download changes from remote (doesn\u2019t merge).\n\ngit fetch --all # Fetch from all remotes.\n</code></pre>"},{"location":"remotes/#pulling","title":"Pulling","text":"<p>It is essentially the combination of fetch and merge</p> <pre><code>git pull &lt;remote&gt; &lt;branch&gt; # Fetch + merge changes from remote into current branch.\n\ngit pull --rebase # Fetch + reapply your changes on top (avoids merge commits).\n</code></pre>"},{"location":"remotes/#pushing","title":"Pushing","text":"<pre><code>git push &lt;remote&gt; &lt;branch&gt; # Push local branch to remote.\n\ngit push -u &lt;remote&gt; &lt;branch&gt; \u2192 Push and set upstream (so you can just git push next time).\n\ngit push --all \u2192 Push all branches.\n\ngit push --tags \u2192 Push all tags.\n\ngit push &lt;remote&gt; --delete &lt;branch&gt; \u2192 Delete a branch from remote.\n</code></pre>"},{"location":"remotes/#tracking-upstream","title":"Tracking &amp; Upstream","text":"<pre><code>git branch -r \u2192 Show remote-tracking branches.\n\ngit branch -a \u2192 Show all branches (local + remote).\n\ngit branch --set-upstream-to=&lt;remote&gt;/&lt;branch&gt; \u2192 Link local branch to remote branch.\n\ngit fetch -p \u2192 Prune (remove deleted remote branches from local references).\n</code></pre>"}]}